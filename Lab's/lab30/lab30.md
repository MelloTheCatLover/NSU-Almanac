Что такое сокет?

Сокет - специальное псевдоустройство подсистемы STREAMS, используемое для связи между процессами на одной машине или на разных.
  Являются улучшенной версией труб (pipe), которые также позволяют передавать данные между процессами, но обладают рядом недостатков:
    - позволяют передавать данные лишь локально и между двумя процессами (тогда как сокеты позволяют общаться множеству процессов с одним, хранящим серверный сокет (listen(2)))
    - Однонаправленные, тогда как сокеты двунаправленные


socket(2) - создаёт точку связи и возвращает его дескриптор
  int socket(int domain, int type, int protocol)
  domain:
    AF_UNIX / AF_LOCAL - Unix domain socket
      Unix Domain Socket позволяет связываться процессам через сокет в рамках одной системы. 
      Права доступа к сокетам будут определяться простыми правами доступа файлов
    AF_INET - IPv4
    AF_INET6 - IPv6
  type:
    SOCK_STREAM - двунаправленный сокет для передачи потока байтов
    SOCK_DGRAM - сокеты для передачи пакетов (датаграмм)
  Подробнее о доменах, типах и протоколах смотри man -s 2 socket

bind(2) - привязывает имя сокета с его дескриптором
  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

  bind привязывает к сокету sockfd локальный адрес my_addr длиной addrlen. Традиционно, эта операция называется lqприсваивание сокету имени.rq Когда сокет только что создан с помощью socket(2), он существует в пространстве имён (семействе адресов), но не имеет назначенного имени.


  struct sockaddr {
      sa_family_t sa_family; // domain
      char        sa_data[14]; // socket name
  }; - общая версия структуры


  struct sockaddr_un {
      sa_family_t sun_family;               // AF_UNIX
      char        sun_path[UNIX_PATH_MAX];  // pathname
  }; - версия для работы с доменом AF_UNIX



accept(2)
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  Принимает первый в очереди запрос на соединение с сокетом sockfd и возвращает дескриптор на новый сокет, который не будет в состоянии прослушивания и будет связан с обрабатываемым клиентом
  Если передать указатели вторым и третьим аргументами, они будут заполнены данными созданного сокета-клиента
  Если очередь запросов пуста и сокет не отмечен как неблокирующий, процесс будет заблокирован, пока не появится запрос к сокету. Если сокет неблокирующий, то accept завершится с ошибкой EAGAIN или EWOULDBLOCK
  Вместо ожидания в блоке можно использовать select(2) или poll(2), которые сообщат о появлении запроса в очереди

connect(2)
  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  Соединяет дескриптор сокета sockfd с адресом, определённым в структуре addr

read/write и другие базовые IO операции для сокетов работают через драйвера

как работает atexit()? В частности, как он работает, если в конце функции у нас return, а не exit?
*/





Чем сокерт трубы:



бинд связывает дескриптор с каким-то файлом.


> Сокет - 

Зачем нужно bind. 

Почему он существет

Почему существует лисен если есть бинд 

`Сокет` - псевдоустройство специального типа, тоже интерфейс гармонического межпроцессного взаимодействия

> Разница именнованный трубы и сокета

Когда процессы взаимодействуют через трубу данные перемешивабтся(все процессы пишут в одно место, нужно продумать как это структурировано), через сокеты процессы взаимодействуют через отдельный stream.

Сигнал - это механизм предназанченнй процессу для сообщения процессом определенных событий. 

Сокет - специальное псевдоустройство подсистемы STREAMS, используемое для связи между процессами на одной машине или на разных.


`Критическая секция` - кусок кода либо время выполнения куска кода, который нарушает целостность разделяемых данных либо полагается на их целостность (при том, что эта структура может быть измнена где-то ещё).

`Критические секции `- шаг к решению race condition - так как распознав критические секций, мы выделяем и безопасные

Если вы не думаете о критических секциях, ваша программа вся будет одной критической секцией (хотя бы часть данных всё время не целостна)

**Подходы к решению проблемы критических секций:**

* Выделение критических секций и блокировки
  * Используется в Java и самый популярный
* Отказ от изменяемых разделяемых данных
  * Использование иммутабельных данных (Функциональные языки (Haskell!!!), Java Streams, Python tuples)
  * Гармонической взаимодействие (трубы, сокеты)
* Copy-modify-merge - делает копию разделяемых структур по методу copy-on-write, а потом пытался провести слияние
  * Заставить человека решить конфликт вручную (системы контроля версий)
  * Транзакции - откат при конфликте (БД)
* Lockless-программирование - писать программы так, чтобы либо не полагаться на целостность разделяемых данных, либо не нарушать её. Очень странный метод, сложный для понимания и поддержания


`Примитив` - переменная непрозрачного типа, над которой определён некоторый набор опреаций.

* Допустимо использовать определённые для примитива операции, мимо них работать с объектом примитива не стоит, иначе, для примитивов синхронизации в частности, мы можем получить ошибку соревнования
* Сравним с объектом с инкапсуляцией, но понятие примтива появилось задолго до ООП
Простейшие примитивы позволяют создать более сложные примитивы синхронизации.

**Гармоническое взаимодействие**

1.Каждый процесс представляет собой независимый программный модуль, для которого создается иллюзия чисто последовательного исполнения.

2.Процессы не имеют разделяемых данных.

3.Все взаимодействие происходит в выделенных точках процессов. В этих точках процесс, передающий данные, останавливается и ждет, пока его партнер будет готов эти данные принять. В некоторых реализациях процесс-передатчик может не ожидать приема, а просто складывать данные в системный буфер. Аналогично, процесс, принимающий данные, ожидает, пока ему передадут данные. Иными словами, все передачи данных неразрывно связаны с синхронизацией.

4.Синхронизация, не сопровождающаяся передачей данных, лишена смысла - процессы, не имеющие разделяемых структур данных, совершенно независимы и не имеют ни критических точек.



    Понимание гармонического взаимодействия - 


  Являются улучшенной версией труб (pipe), которые также позволяют передавать данные между процессами, но обладают рядом недостатков:
    - позволяют передавать данные лишь локально и между двумя процессами (тогда как сокеты позволяют общаться множеству процессов с одним, хранящим серверный сокет (listen(2)))
    - Однонаправленные, тогда как сокеты двунаправленные 






> Отркуть сокет

> Забиндить 

bind(2) 
  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

  bind привязывает к сокету sockfd локальный адрес my_addr длиной addrlen. Традиционно, эта операция называется lqприсваивание сокету имени.rq Когда сокет только что создан с помощью socket(2), он существует в пространстве имён (семействе адресов), но не имеет назначенного имени.


  struct sockaddr {
      sa_family_t sa_family; // domain
      char        sa_data[14]; // socket name
  }; - общая версия структуры

  
  struct sockaddr_un {
      sa_family_t sun_family;               // AF_UNIX
      char        sun_path[UNIX_PATH_MAX];  // pathname
  }; - версия для работы с доменом AF_UNIX

> Начать слушать

listen(2)
  int listen(int sockfd, int backlog);
  Помечает сокет по дескриптору sockfd как пассивный, то есть сокет, который будет принимать входящие подключения через accept(2)
    Иначе говоря, регистрирует сокет как серверный
  backlog показывает максимальную длину очереди ожидаемых подключений от клиентов 
       сокет, то есть как сокет, который будет использоваться для приема входящих
       запросы на соединение с использованием Accept(2).

       Аргумент sockfd — это файловый дескриптор, ссылающийся на сокет.
       типа SOCK_STREAM или SOCK_SEQPACKET.

       Аргумент backlog определяет максимальную длину, до которой
       очередь ожидающих соединений для sockfd может вырасти. Если
       запрос на соединение поступает, когда очередь заполнена, клиент может
       получить ошибку с указанием ECONNREFUSED или, если
       базовый протокол поддерживает повторную передачу, запрос может быть
       игнорируется, чтобы более поздняя повторная попытка подключения была успешной.
       
  Перед использованием listen должны быть вызваны socket(2) для создания сокета и bind(2) для возможности обращаться к сокету извне

> Что происходит под капотом
>

> Как правильно читать и писать в сокет

Программные каналы можно сдать. Лабы через программные каналы, сигналы. Сдать первую лабу 


Когда несколько процессов пытаются получить доступ к одному и тому же сегменту кода, этот сегмент называется критической секцией. Критическая секция содержит общие переменные или ресурсы, которые должны быть синхронизированы для поддержания согласованности переменных данных.

Проще говоря, критическая секция - это группа инструкций/выражений или областей кода, которые должны выполняться атомарно (читайте этот пост об атомарности), например, при доступе к ресурсу (файлу, порту ввода или вывода, глобальным данным и т. д.) В параллельном программировании, если один поток пытается изменить значение общих данных в то же время, когда другой поток пытается прочитать это значение (т. е. гонка данных между потоками), результат будет непредсказуемым. Доступ к таким общим переменным (общая память, общие файлы, общий порт и т. д.) должен быть синхронизирован.

Проблема критических секций
Использование критических секций в программе может вызвать ряд проблем, в том числе:

Тупик: Когда два или более потока или процесса ожидают друг друга, чтобы освободить критическую секцию, это может привести к тупиковой ситуации, в которой ни один из потоков или процессов не может двигаться. Тупики трудно обнаружить и устранить, и они могут существенно повлиять на производительность и надежность программы.

Голодание: Если потоку или процессу постоянно мешают войти в критическую секцию, это может привести к голоданию, при котором поток или процесс не может продвигаться вперед. Это может произойти, если критическая секция удерживается в течение необычно долгого периода времени или если высокоприоритетный поток или процесс всегда получает приоритет при входе в критическую секцию.

Проблемы гармонического взаимодействия
Работа с копиями данных
Требуется доплонительная память
Время на копирование
Данные могут быть не актуальны
Нет произвольного доступа к данным
Нет разделяемых данных, а они могут нам понадобиться

