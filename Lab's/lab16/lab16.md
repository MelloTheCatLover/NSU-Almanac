
Понятие файла в UNIX распространяется на все сущности, поддерживающие ввод-вывод, в т.ч. каталоги символических ссылок, аппаратные устройства, псевдоустройства и элементы коммуникаций (каналы и сокеты).


`Порт` - аппаратный интерфейс ввода-вывода.

`Драйвер устройства` - программный интерфейс доступа к порту. Драйвер содержит функции для работы с ядром для работы с портами.

`Файл-устройство` - файл, за реализацию операций ввода-вывода для которого отвечает драйвер. Благодаря этому даже с очень разными устройствами процессы могут взаимодействовать через стандартный интерфейс ввода-вывод (write(2), read(2) и др.)

`Псевдоустройство` - виртуальный объект, обслуживаниемый специальным драйвером, поддерживаемым все те же интерфейсы, что и обычный.

**Устройства подразделяются на символьные и блочные**:

* Символьные устройства должны реализовывать базовые функции из структуры struct cdevsw: open, close, read, write и, возможно, другие.
    Структура struct cdevsw хранится в виде глобального массива cdevsw[], который называется `переключателем символьных устройств`.

    Каждое устройство имеет в нём свой уникальный индекс (основной номер устройства) на структуру, содержащую реализованные для этого устройства функции.
    Основной номер устройства хранится в inode символьного устройства.


> Что такое терминал и псевдо-терминал? 

`Терминал` - устройство ввода-вывод для работы с текстовой информацией. 
  
`Псевдотерминал`, как следует из определения устройства, имитирует поведение обычного терминала. Используется для удалённого подключения по ssh и другим протоколам, а также для терминальных сессий.

**Состоит псевдотерминал из двух псевдоустройств:** 

* ведущего /dev/pts/XX
* ведомого /dev/pty/XX 

- подаваемые в ведущий терминал данные будут считываться ведомым и наоборот.
Вводимые с клавиатуры символы идут из ведомого устройства в ведущее, а затем в стандартный поток ввода (дескриптор 1).
Получаемые в потоки вывода и ошибок (дескрипторы 1 и 2) ведущего устройства считываются в ведомом и отображаются в окне псевдотерминала.

-------

**open(2)** открывает файл терминала также, как любой регулярный файл.

`/dev/term/XX` - хранит физические терминалы
`/dev/pty/XX` - хранит псевдотерминалы (причём их ведомую часть)
`/dev/tty` - управляющий терминал текущей сессии

**ioctl(2)** - позволяет отправлять непечатные команды, конфигурировать порты и управлять функциями терминальной дисциплины. Не стандартизирован, поэтому куда предпочтительнее использовать termios(3C) 

**isatty(3F)** - проверяет, относится ли переданный дескриптор к терминалу. Если вернул ненулевое значение, значит это так

**read(2)** - считывает текстовые данные из файла-терминала также, как и из регулярного. Может считать не всю строку либо получить меньше байт, чем запрашивал
    В обычном случае данные при чтении из терминала уничтожаются, то есть повторно они быть прочитанными не могут

**write(2)** - записывает буфер в терминал

**poll(2)** и **select(2)** используются для работы сразу с несколькими устройствами, работа с которыми может привести к блокировке

**close(2)** закрывает дескриптор терминала

**lseek(2)** и **mmap(2)** не поддерживаются терминалами

**libcurses(3LIB)** - бибилиотека для генерации кодов расширения терминала.
    Может с одной стороны, создавать коды расширения для выполнения различных функций, с другой - интерпретировать коды расширения, посылаемые терминалом и переводить их в независимые от конкретной моедли терминала символы
    Тип терминала определён переменной среды TERM.
    Тип сопоставлется с записями в базе данных-катлоге /usr/share/lib/terminfo/. 
      Там хранятся таблицы для всех известных терминалов. В таблицах указаны команды и соответствующие им коды расширения.
    При необходимости libcurses может провести некоторую оптимизацию: 
      Если запрашиваемая команда поддерживается треминалом, библиотека просто вернёт эту команду
      Если команда не поддерживается, библиотека сгенерирует последовательность поддерживаемых команд, приводящую к тому же результату
  В терминале есть 2 очереди ввода и одна вывода.
    Вводимые с клавиатуры символы помещаются в "сырую" очередь. При включённой функции эха направляются в очередь вывода.
    Программы читают строки из канонической очереди ввода. Туда помещаются символы из сырой очереди после ввода переноса строки. 
    Помещаемая в каноническую очередь строка также подвергается дополнительной обработке.
    Каноническая преобработка поддерживает забой и стирание.
    - Забой (ASCII BS / ASCII DEL) - код расширения удалится вместе с идущим перед ним символом (то есть в сыром вводе у нас останется и символ сам символ, и код расширения)
    - Стирание KILL сотрёт всю текущую строку перед собой


**termios(3C)** - универсальный интерфейс для управления терминальными устройствами. Соответствует POSIX

**Структура struct termios содержит поля с флагами, отвечающими за различные параметры терминала:**

    struct termios {
    tcflag_t c_iflag;      // input modes - управление преобработкой ввода
    tcflag_t c_oflag;      // output modes - управелние системной постобработкой вывода
    tcflag_t c_cflag;      // control modes - параметры, отвечавшие за настройку порта RS232 для конкретного терминала. В псевдотерминалах почти ни на что не влияют
    tcflag_t c_lflag;      // local modes - управление разбиением потока на строки, здесь можно отаключить канонический ввод
    cc_t     c_cc[NCCS];   // special characters - коды расширения
    }

**tcflag_t** - битовая маски
Флагов существует огромное множество, для подробного описания целесообразнее смотреть man termios и выбирать флаги под конкретные цели.

**Заслуживающим внимание является настройка параметров терминала для работы с иными устройствами ввода-вывода через порт RS232:**
- Отключить канонический ввод
- Включить обмен восьмибитными данными в обе стороны
- Запретить отображение символов (CR в NL и т.п.) и управление потоком (IXANY и т.п.)
- Выключить эхо
- Устранить значения всех спецсимволов


tcgetattr(int terminalDescriptor, termios_p structPointer)
  записывает по указателю structPointer данные структуры struct termios терминала по переданному дескриптору
tcsetattr(int terminalDescriptor, int when_set, termios_p structPointer)
  сохраняет параметры структуры struct termios по указателю termios_p в терминал по переданному дескриптору. 
  При этом меняться будет не структура file_t, а, собственно, сама vnode, поэтому при экстренном завершении программы терминал может остаться в изменённом состоянии. Починить его можно пытаться командой stty(1)
  when_set указывает, в какой момент необходимо сохранить параметры:
    TCSANOW - немедленно
    TCSADRAIN - когда были переданы все направленные на вывод данные. Следует использовать при изменении флагов c_oflag
    TCSAFLUSH - когда были переданы все направленные на вывод данные и были обработаны все полученные на ввод данные.


**Отличия терминалов и псевдотерминалов**
`Терминал` - электронное печатное устройство.
  
**Что такое сессия?**

`Сессия` - объединение процессов. Лидер сессии - процесс, который создал сессию вызовом setsid. 
Все последующие создаваемые процессом-лидером процессы будут относиться к той же сессии.
Чтобы дать пользователю возможность управлять процессами в сессии. Ей назначается управляющий терминал

**Как терминалы связаны с процессами?**
Управляющий терминал сессии может запускать процессы, которые будут принадлежать к этой сессии. 
Далее терминал может с ними работать: отправлять сигналы, перемещать из группы первого плана и в неё (bg(1), fg(1)).


> Что такое файловая система?


> Зачем нужна файловая система?


Данные по сокету в диске не располагаются 

Абстрактное описанеи дескрипторов файла.

> Что твкое устройство

Реальное устройство 

![Alt text](image.png)


> Как терминалы связаны с поцессами

> Файл это устройство. Под словом файл и под словом устройство, нужно чтобы все друг друга поняли

За взаимодействия с устройством всецело отвечает драйвер этого устройства. Каждый драйвер управляет одним или несколькими сходными устройствами. Например, один дисковый драйвер может управлять несколькими дисками. Драйвер является единственным компонентом системы, который владеет информацией об аппаратных характеристиках устройства, таких как количество секторов, дорожек и головок диска или скорости передачи в бодах (baud rates) последовательной линии.

`Драйверы` устройств являются частью ядра и представляют собой набор структур данных и функций, управляющих одним или несколькими устройствами и взаимодействующих с остальной частью ядра посредством определенного интерфейса. 

Драйвер во многом отличается от внутренних компонентов ядра и является обособленным от них. 

`Драйвер` - это единственный модуль ядра, который может взаимодействовать с устройством. 
Драйверы часто создаются 
![Alt text](image-1.png)